---
title: 数据结构和算法
date: 2020-08-24 13:14:47
---
##### 写在前面
- 线性结构作为最常用的数据结构，其特点是数据元素之间存在一对一的线性关系，线性结构拥有两种不同的存储结构，即顺序存储结构和链式存储结构
- 非线性结构特点是一个结点元素可能有多个直接前驱和多个直接后继。常见的非线性结构有：二（多）维数组、树、图

##### 数组
- 线性表
- 连续的内存空间 声明数组时需要预先指定大小
- 存储相同类型的数据
- 随机访问

##### 链表

- 当一个List拥有快速访问功能时，其遍历方法采用for循环最快速。而没有快速访问功能的List，遍历的时候采用Iterator迭代器最快速。
  当我们不明确获取到的是Arraylist，还是LinkedList的时候，我们可以通过RandomAccess来判断其是否支持快速随机访问，若支持则采用for循环遍历，否则采用迭代器遍历。
ArrayList 其实就是一个动态数组。优势就是将数组的操作封装起来，比如增删查，以及**动态扩容**，  每次1.5倍：`int newCapacity = oldCapacity + (oldCapacity >> 1);`，同时还会防止溢出进行比较`MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8`。
ArrayList中的线程安全问题：size成员变量问题，设置值得时候的原子性操作问题`elementData[size++] = e;`元素减少，缩容：`elementData[--size] = null; // clear to let GC do its work`,`trimToSize()`

- ArrayList.subList() 方法返回的List是ArrayList中某段数据的一个视图. 因此, 在操作此方法返回的List时, 同样会改变ArrayList的数据，同样在CopyOnWriteArrayList也存在这个问题，获取到一个远列表的试图，因此取subList时需要考虑线程安全问题，更好的方式是使用不可变列表（例如Guava的ImmutableList），避免对原始列表的更新导致子列表抛出异常
- Fail-Fast机制只能用作bug判断，并不是一个强保证。也好理解，其实多线程环境下也不是一定会触发抛ConcurrentModificationException异常的条件
- Fail-Safe任何对集合结构的修改都会在一个复制的集合上进行修改，但是会有一下问题
需要复制集合，产生大量的无效对象，开销大；无法保证读取的数据是目前原始数据结构中的数据

- Vector和ArrayList基本一样，线程安全；Vector可以设置capacityIncreament(容量增长量)，而ArrayList不可以
- CopyOnWriteArrayList的几个特点：thread-safe：对于引起list变化（内容或者结构）都是使用ReentrantLock加锁，然后通过底层的数组copy完成的。虽然可以保证安全，但是觉得效率低呀，需要额外的复制数据的操作，只适合读操作远多于写操作的场景。

##### 栈

- 先进后出，后进先出
- 栈又分顺序栈和链式栈。基于数组实现的栈叫做顺序栈，基于链表实现的则叫链式栈
- 堆是堆（heap），栈是栈（stack），堆栈是栈
- 函数调用的局部状态之所以用栈来记录是因为这些数据的存活时间满足“后入先出”（LIFO）顺序，而栈的基本操作正好就是支持这种顺序的访问
- 栈这个数据结构，真正模拟的，其实是 嵌套关系，一切具备嵌套性质的东西，用堆栈做是最自然的
- Java中的Stack类，由于是继承于Vector，所以它是线程安全的，其本质上是由数组这个基本数据结构实现的，知道这点之后可以更好的进行理解。

##### 队列


##### 树
- 每个节点都只有有限个子节点或无子节点； 没有父节点的节点称为根节点； 每一个非根节点有且只有一个父节点； 除了根节点外，每个子节点可以分为多个不相交的子树； 树里面没有环路
- 相关名词：层，根节点，子节点，父节点，兄弟节点，叶子节点，度数
- 树节点的度数即为该节点孩子的个数，一棵树的度指其中节点的度最大值
- 二叉树，每个结点至多拥有两棵子树（即二叉树中不存在度大于2的结点），若二叉树的层次从0开始，则在二叉树的第i层至多有2^i个结点（i>=0）
![nginx-logo](https://azou.tech/blog/static/image/full_complete_perfect_tree.png)
- 完美二叉树Perfect Binary Tree(PBT)，国内一般称之为满二叉树，所有的叶子节点具有相同的深度。完美(Perfect)二叉树一定是完全(Complete)二叉树，但完全(Complete)二叉树不一定是完美(Perfect)二叉树；完美(Perfect)二叉树一定是完满(Full)二叉树，但完满(Full)二叉树不一定是完美(Perfect)二叉树
- 完全二叉树Complete Binary Tree （CBT)，从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。

- 完满二叉树Full Binary Tree (FBT)，所有非叶子结点的度都是2。（只要你有孩子，你就必然是有两个孩子）
- 平衡二叉树，

##### 好玩的
```lua
-- 配合各种Escape Sequence
string.rep('hahaha\t', 10)
```
##### 相关介绍

- lua 的 metatable 和 js的 prototype





##### 参考
- 极客时间-数据结构与算法
- https://www.lua.org/manual/5.3/manual.html

