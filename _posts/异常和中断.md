---

title: 异常和中断

date: 2021-03-18 11:40:17

categories: [操作系统]

---

### 异常控制流

中断 interrupt 异步，返回处理下一条指令

故障（fault） 同步 返回当前指令

陷阱（trap）有意的异常 返回到下一条指令

终止（abort）不可恢复的错误，不会返回



###异常

异常从大的层面分为内部异常和外部异常，但还是处理器内部的中断信号

内部异常：指令执行 结果溢出，越界等

外部异常：硬件掉电等



###中断

外设通过中断请求信号线向CPU提出中断请求，让CPU暂时停止当前程序的执行转而去执行处理新情况的程序和执行过程。

CPU对于中断和异常的具体处理机制本质上是完全一致的。

广义上的中断包含异步中断和同步中断，同步中断又称之为异常，异步中断则称之为中断，通常情况下我们所讲的中断都是异步中断。



####软中断和硬中断

硬中断：一般的硬件中断，也就是常说的中断，由硬件触发。

软中断：软中断是一组静态定义的下半部分接口，可以在所有的处理器上同时执行，即使两个类型相同也可以。但是一个软中断不会抢占另外的一个软中断，唯一可以抢占软中断的是硬中断。

为了满足实时系统的要求，中断处理应该越快越好。编写驱动程序的时候，一个中断产生之后，内核在中断处理函数中可能需要完成很多工作。但是中断处理函数的处理是关闭了中断的。也就是说在响应中断时，系统不能再次响应外部的其它中断。这样的后果会造成有可能丢失外部中断。于是，linux内核设计出了一种架构，中断函数需要处理的任务分为两部分，一部分在中断处理函数中执行，这时系统关闭中断。另外一部分在软件中断中执行，这个时候开启中断，系统可以响应外部中断。
 Linux为了实现这个特点，当中断发生的时候硬中断处理那些短时间，就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。

软中断发生的时间是由程序控制的,而硬中断发生的时间是随机的 

软中断是由程序调用发生的,而硬中断是由外设引发的 

硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。

软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。

####中断的优先级

各个中断具有不同的优先级，表示事件的紧急程度。

在不同级别的中断同时到达的情况下，级别最高的中断源先被响应，同时封锁对其他中断的响应；它被响应之后，解除封锁，再响应次高级的中断。如此下去，级别最低的中断最后被响应。

级别高的中断一般有打断级别低的中断处理程序的权利。就是说，当级别低的中断处理程序正在执行时，如果发生级别比它高的中断，则立即中止该程序的执行，转去执行高级中断处理程序。后者处理完才返回刚才被中止的断点，继续处理前面那个低级中断。但是，在处理高级中断过程中，不允许低级中断干扰它，通常也不允许后来的中断打断同级中断的处理过程。

#### 中断屏蔽

提出中断请求之后，CPU不予响应的状态。它常常用来在处理某个中断时防止同级中断的干扰，或在处理一段不可分割的、必须连续执行的程序时防止意外事件把它打断。

屏蔽的方式：

整级的屏蔽，通过设置某些位来屏蔽某些中断，通过设置位信息来更改屏蔽信息

在UNIX系统中，通常采用提高处理机执行优先级的方式屏蔽中断，即在程序状态寄存器(PS)中设置处理机当前的执行优先级，当它的值(比如6)大于或等于后来中断事件的优先级(比如4)时，该中断就被屏蔽了。



#### 多重中断

顺序处理：没有考虑中断的相对优先级或时间的紧迫程度。

嵌套处理：对每类中断赋予不同的优先级，允许高优先级中断打断低优先级中断的处理程序。



####中断禁止

可引起中断的事件发生时系统不接收该中断信号，因而就不可能提出中断请求而导致中断。简言之，就是不让某些事件产生中断。在中断禁止的情况下，CPU正常运行，根本不理睬所发生的那些事件。

####中断的处理过程

1. 关中断，让CPU处于’禁止中断‘状态

2. 保存现场，这各种寄存器

3. 中断处理

   1. 中断类型识别

      1. 软件识别（由中断识别程序来确定到底是什么中断类型，然后在跳转到对应的程序段进行处理）

      2. 硬件识别（速度快，向量中断（一种硬件中断识别方式），专门的硬件查询电路按照优先级顺序进行识别，得到中断类型号，然后从中断向量表中读取到中断服务程序的入口地址）

         1. 中断向量表 （IA-32架构）

            1. 中断向量号， 一共256个，前32（0-31）个保留给CPU使用，剩余的可以让用户自定义（这里的用户就是操作系统）

            2. 通过 INT n（中断类型号）指令，CPU自动的转到OS给出的中断服务程序执行

            3. 在实地址模式下和保护模式下的向量表的不同设计

            4. BIOS启动过程中的中断向量表的加载
   2. 得到中断服务程序的地址信息
   3. 安全判断
   4. 用户态切换到内核态，使用内核栈，在内核栈中保存原来用户栈的相关信息（保存现场）  
   5. 中断处理完毕，最后一条指令是IRET，从内核态回到用户态        

#### 系统调用中断



#### 时钟中断

时钟分为绝对时钟和间隔时钟，是操作系统进行调度的重要工具，负责维护系统绝对时间和日期，让分时进程按时间片轮转，让实时进程定时发送或接受控制信号等。陷入死循环的进程最终会因时间片耗尽而被迫让出处理器。

对于**绝对时钟**，系统会设置一个绝对时钟寄存器，定时的把寄存器的内容加 1，如果寄存器的初始内容是 0，那么就可以根据系统开机时间计算出当前时间。从 Linux V2.5 开始，时钟中断频率已经提高至 1000 Hz，即每 1 ms 产生一次 1 次时钟中断。

**间隔时钟**寄存器处理则刚好相反，每个时间切换点内容会减 1，内容减到 0 时，就会产生间隔时钟中断。通过程序设置初始寄存器初始值。如果进程需要延迟执行，也可通过系统调用将间隔时钟设为挂起状态，等到时钟中断产生，操作系统就会唤起该进程。

有了硬件定时器，系统就可以记录进程的创建时间及进程在生命周期内占用 CPU 的时间。`ps -o`能查看某 Linux 系统某进程的开始时间、结束时间和运行时间。

Linux 系统运行了不同的间隔定时器： real、virtual、profile，分别统计不同状态的耗时。在进程中同时设定这三个定时器，就可以了解进程在用户态、内核态和总的执行时间。

####异常和中断的区别：

1. 中断产生于处理器外部，异常产生于处理器内部

2. 异常不可被屏蔽，中断可以被屏蔽，高优先级的中断可以屏蔽低优先级的中断

3. 中断不可被阻塞，异常可以被阻塞

   










- 参考

  1. http://www.yaoyanhuo.com/blog/interrupt/

  

