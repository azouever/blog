---

title: 并发编程

date: 2020-08-27 13:42:17

---

> 以Java语言来进行描述

##### 进程，线程，协程
##### 进程基础
##### 线程基础
##### 什么是线程安全和线程不安全

##### 关于synchronized
> 加锁过程：
如果 monitor 的进入数为0，则该线程进入 monitor，然后将进入数设置为1，该线程即为 monitor 的所有者；
如果线程已经占有monitor，只是重新进入，则monitor的进入数+1；
如果其他线程已经占用 monitor，则该线程处于阻塞状态，直至 monitor 的进入数为0，再重新尝试获得 monitor 的所有权
>
> 释放锁过程：
monitorexit：执行 monitorexit 的线程必须是 objectref 所对应的 monitor 的所有者。执行指令时，monitor 的进入数减1，如果减1后进入数为0，则线程退出 monitor，不再是这个 monitor 的所有者，其他被这个 monitor 阻塞的线程可以尝试获取这个 monitor 的所有权。
>

1. 确保线程互斥的访问代码块，同一时刻只有一个方法可以进入到临界区
2. monitorenter 指令在编译为字节码后插入到同步代码块的开始位置，monitorexit 指令在编译为字节码后插入到方法结束处和异常处。JVM 要保证每个 monitorenter 必须有对应的 moniorexit。
3. monitorenter：每个对象都有一个监视器锁（monitor），当 monitor 被某个线程占用时就会处于锁定状态，线程执行 monitorenter 指令时尝试获得 monitor 的所有权，即尝试获取对象的锁。过程如下：
4. ObjectMonitor 的几个核心属性：

``` java
ObjectMonitor() {
	...
    _count        = 0;      //记录个数
    _owner        = NULL;   //持有monitor的线程
    _WaitSet      = NULL;   //处于wait状态的线程，会被加入到_WaitSet
    _EntryList    = NULL ;  //处于等待锁block状态的线程，会被加入到该列表
    ...
  }
```
##### synchronized的优化
> 无锁-->轻量级锁-->偏向锁-->重量级锁
> 
> 锁随着竞争情况可以升级，但锁升级后不能降级，意味着不能从轻量级锁状态降级为偏向锁状态，也不能从重量级锁状态降级为轻量级锁状态
> 
> 自旋锁和适应自旋

1. JVM中对象的内存布局
在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头(Header)，实例数据( Instance Data)和对齐填充(Padding)。

2. 这里我们主要看一下对象头。第一块，Mark Word：存储对象自身的运行时数据，如：Hash Code，GC 分代年龄、锁信息。这部分数据在32位和64位的 JVM 中分别为 32bit 和 64bit。考虑空间效率，Mark Word 被设计为非固定的数据结构，以便在极小的空间内存储尽量多的信息。第二块，存储指向方法区对象类型数据的指针，如果是数组对象的话，额外会存储数组的长度。



 
	





##### Lua好玩的
```lua
-- 配合各种Escape Sequence
string.rep('hahaha\t', 10)
```
##### 相关介绍




##### 参考
- https://www.tutorialspoint.com/lua/index.htm

