---

title: 对于JVM的理解

date: 2020-09-19 22:13:17

---
##### 几大模块


1. 关于方法区

Java7和Java8内存结构的不同主要体现在方法区的实现

方法区是java虚拟机规范中定义的一种概念上的区域，不同的厂商可以对虚拟机进行不同的实现。
我们通常使用的Java SE都是由Sun JDK和OpenJDK所提供，这也是应用最广泛的版本。而该版本使用的VM就是HotSpot VM。通常情况下，我们所讲的java虚拟机指的就是HotSpot的版本。

JDK 1.7中，绝大部分Java程序员应该都见过java.lang.OutOfMemoryError: PremGen space异常。这里的PermGen space其实指的就是方法区。不过方法区和PermGen space又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现

>  JDK 1.7中，存储在永久代的部分数据就已经转移到Java Heap或者Native Heap。
> 但永久代仍存在于JDK 1.7中，并没有完全移除，譬如符号引用(Symbols)转移到了native heap；字面量(interned strings)、类的静态变量转移到了Java heap。
> 
> JDK1.8和JDK1.7的jvm内存最大的区别是, 在1.8中方法区是由元空间(元数据区)来实现的，常量池移到堆中。
1.8中方法区的实现换成了元空间，而是在本地内存中,新加入元数据区(元空间).
元空间: 存储.class 信息, 类的信息,方法的定义,静态变量等.
> 
> 而常量池放到堆里存储

- 对于元数据区配置

``` 
-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。
-XX：MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。
-XX：MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。
-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。

```

##### class文件分析
##### 类加载机制

> Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的加载机制。

###### 类加载过程

> 类装载器就是寻找类的字节码文件，并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤： 
> load--->link(check,prepare-parse)--->initialization--->using--->unloading

```
装载：查找和导入Class文件；
链接：把类的二进制数据合并到JRE中；
  (a)校验：检查载入Class文件数据的正确性；
  (b)准备：给类的静态变量分配存储空间；
  (c)解析：将符号引用转成直接引用；
 初始化：对类的静态变量，静态代码块执行初始化操作
```

- 加载阶段

	1. 通过一个类的全限定名称来获取定义此类的二进制字节流。

	2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。

	3. 在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

- 验证阶段

	确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。

1. 文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。
2. 元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。
3. 字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。
4. 符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。

- 准备阶段

>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。

1. 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。
2. 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。

- 解析阶段

> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
> 
> 分派指的是确定方法调用版本，又分为静态分派和动态分派。
静态分派是在编译期即根据变量的静态类型即可确定方法调用版本，静态分派的典型应用是方法重载；
动态分派是需要在运行时根据实际类型才能确定方法调用版本，静态分派的典型应用是方法重写；

- 初始化阶段

- 卸载阶段

> 一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期

> 加载器和Class对象：在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。
> 另一方面，一个Class对象总是会引用它的类加载器。调用Class对象的getClassLoader()方法，就能获得它的类加载器。由此可见，Class实例和加载它的加载器之间为双向关联关系。
> 
> 类、类的Class对象、类的实例对象：一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。 
> 
> 由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。
 Java虚拟机自带的类加载器包括根类加载器、扩展类加载器和系统类加载器。
Java虚拟机本身会始终引用这些类加载器，而这些类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的。
由用户自定义的类加载器加载的类是可以被卸载的。



###### 符号引用和直接引用

1. 符号引用：以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。
2. 直接引用：直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。


###### 双亲委派模型

> 如果一个类加载器收到了加载某个类的请求,则该类加载器并不会去加载该类,而是把这个请求委派给父类加载器,每一个层次的类加载器都是如此,因此所有的类加载请求最终都会传送到顶端的启动类加载器;只有当父类加载器在其搜索范围内无法找到所需的类,并将该结果反馈给子类加载器,子类加载器会尝试去自己加载。

1. 子类先委托父类加载
2. 父类加载器有自己的加载范围，范围内没有找到，则不加载，并返回给子类
3. 子类在收到父类无法加载的时候，才会自己去加载

> 双亲委派模型的破坏
> 
> 当高层提供了统一接口让低层去实现，同时又要是在高层加载（或实例化）低层的类时，必须通过线程上下文类加载器来帮助高层的ClassLoader找到并加载该类。
> 
> 上下文类加载器默认情况下就是Application ClassLoader。
> 

> 服务加载器在Java SE 6后才开始作为公共API出现，作为一个简单的服务提供者加载设施。ServiceLoader也像ClassLoader一样，能装载类文件，但是使用时有区别，具体区别如下：
>

1. ServiceLoader装载的是一系列有某种共同特征的实现类（例如实现同一个接口），而ClassLoader是个万能加载器；
2. ServiceLoader装载时需要特殊的配置（配置文件中标明要加载的类URL），使用时也与ClassLoader有所区别；
3. ServiceLoader实现了Iterator接口；

ServiceLoader的缺点：1.ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。2.获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。3.不是单例。

tomcat 类加载器

 -  commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；
 -  catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；
 -  sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；
 -  webappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见；

> 垃圾回收算法
> 垃圾回收器
> 

###### java的几种引用类型
> 当内存空间还足够的时候，这些对象能够保留在内存空间中；如果当内存空间在进行了垃圾收集之后还是非常紧张，则可以抛弃这些对象。基于这种特性，可以满足很多系统的缓存功能的使用场景。
> 

1. StrongReference，如果一个对象具备强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会出现回收具有强引用的对象来解决内存不足的情况。
2. SoftReference，对于软引用关联着的对象，在JVM应用即将发生内存溢出异常之前，将会把这些软引用关联的对象列进去回收对象范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出异常。
3. WeakReference，被弱引用关联的对象只能生存到下一次垃圾收集发生之前，简言之就是：一旦发生GC必定回收被弱引用关联的对象，不管当前的内存是否足够。也就是弱引用只能活到下次GC之时。
4. PhantomReference，一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例(PhantomReference覆盖了Reference#get()并且总是返回null)。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个系统通知。在NIO中，就运用了虚引用管理堆外内存。

###### 关于finalize

> 在GC算法中，有标记-清除、标记-整理算法，他们的标记过程，标记分为两个阶段：

第一次标记：如果对象被判定为不可达对象，也就是从GC ROOTS开始搜索，没有一条引用链可达，这个对象就会被第一次标记，等待被回收。

第二次标记：将第一次标记的对象再进行判定，分析这个对象是否有必要执行**finalize()**方法，如果有必要执行，就从待回收的集合中剔除，放置在一个叫F-Queue的队列之中，并且稍后由一个优先级低的Finalizer线程去取该队列的元素，"尝试执行"元素的finalize()方法。  是否有必要执行，有两点：
	
	对象没有覆盖继承自Object类的finalize()方法，如果没有重写这个方法，没必要执行。
	
	对象的finalize()方法已经被JVM调用过，已经调用过了就不会重复执行。


###### jvm怎么判断哪些对象应该回收呢

> Java虚拟机没有采用引用计数法。它采用的是可达性分析算法。

1. 引用计数算法，在对象中添加一个引用计数器，每当一个地方引用它时，计数器就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。不能解决循环依赖的问题。
2. 从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。所以此对象就是可以被回收的对象。
3. 哪些对象可以作为根对象？

```
虚拟机栈(栈桢中的本地变量表)中的引用的对象。
方法区中的类静态属性引用的对象。
方法区中的常量引用的对象。
本地方法栈中JNI的引用的对象。
```

###### 什么情况下触发full gc
> https://blog.csdn.net/Hollake/article/details/90484027
> 
> 多说一句：当Eden区满时，触发Minor GC。

1. System.gc()方法的调用，建议JVM进行Full GC，但是注意这只是建议，JVM执行不执行是另外一回事儿，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过-XX:+ DisableExplicitGC来禁止RMI调用System.gc。
2. 在Survivor区域的对象满足晋升到老年代的条件时，晋升进入老年代的对象大小大于老年代的可用内存，这个时候会触发Full GC。
3. 统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间。
4. 堆中产生大对象超过阈值，这个参数可以通过-XX:PretenureSizeThreshold进行设定，大对象或者长期存活的对象进入老年代，典型的大对象就是很长的字符串或者数组，它们在被创建后会直接进入老年代，虽然可能新生代中的Eden区域可以放置这个对象，在要放置的时候JVM如果发现老年代的空间不足时，会触发GC。
5. JVM如果判断老年代没有做足够的连续空间来放置大对象，那么就会引起Full GC，例如老年代可用空间大小为200K，但不是连续的，连续内存只要100K，而晋升到老年代的对象大小为120K，由于120＞100的连续空间，所以就会触发Full GC。

Survivor区域对象晋升到老年代有两种情况：

一种是给每个对象定义一个对象计数器，如果对象在Eden区域出生，并且经过了第一次GC，那么就将他的年龄设置为1，在Survivor区域的对象每熬过一次GC，年龄计数器加一，等到到达默认值15时，就会被移动到老年代中，默认值可以通过-XX:MaxTenuringThreshold来设置。
另外一种情况是如果JVM发现Survivor区域中的相同年龄的对象占到所有对象的一半以上时，就会将大于这个年龄的对象移动到老年代，在这批对象在统计后发现可以晋升到老年代，但是发现老年代没有足够的空间来放置这些对象，这就会引起Full GC。

##### 常用的CLI

##### 内存模型
> 不同计算机操作系统对内存模型操作不一样，这时候就要有统一的规范来完成操作。所以就要通过JAVA内存模型（Java Memory Model，JMM）。
> 
>  是一种JAVA虚拟机规范。
> 
> 屏蔽各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
> 

1. 定义程序中各种变量的访问规则，关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节
2. 变量根据是否可以共享划分为：线程私有和线程公有。
	
	线程私有：局部变量与方法参数
	
	线程公有：实例字段、静态字段和构成数组对象的元素

###### 关于volatile

``` 
Java内存模型中定义的8种工作内存与主内存之间的原子操作

lock(锁定)：作用于主内存的变量，把一个变量标识为一条线程独占的状态。
unlock(解锁)：作用于主内存的变量，把一个处于锁定的变量释放出来，释放变量才可以被其他线程锁定。
read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
load(载入)：作用于***工作内存***的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
use(使用)：作用于***工作内***存种的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
assign(赋值)：作用于***工作内存***中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
store(存储)：作用于***工作内存***的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
write(写入)：作用于主内存的变量，它把store操作从工作内存中得到的值放入主内存的变量中。

```

1. 可见性
	核心：volatile变量对对象的操作更严格： read-load-use 和 assign-store-write 两个不可分割的原子操作
2. 禁止指令重排序
3. Java语言中有一个“先行发生”（Happens-Before）的原则

```
Java内存模型下一些天然的先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。存在8中规则：

程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，书写在前面的操作先行发生于书写在后面的操作。注意，这里说的是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是“同一个锁”，而“后面”是指时间上的先后。
volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后。
线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作。
线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread::join()方法是否结束、Thread::isAlive()的返回值等手段检测线程是否已经终止执行。
线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread::interrupted()方法检测到是否有中断发生。
对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

```

##### 常用参数配置

1. -verbose:class 跟踪类的加载和卸载
2. -XX:+TraceClassLoading 跟踪类的加载
3. -XX:+TraceClassUnloading 跟踪类的卸载

##### 好玩的
```lua
-- 配合各种Escape Sequence
string.rep('hahaha\t', 10)
```
##### 相关介绍



##### 参考
- https://juejin.im/post/6844904148375191559
- https://blog.csdn.net/lovely_girl1126/article/details/106806879
- https://juejin.im/post/6844904200015446023
- [垃圾回收并发标记](https://segmentfault.com/a/1190000021820577)
